; configuration.xtm
; 
; loads and reads default and custom configuration files and stores values in a Config*
; object



; Key* object, reference to a specific key on a Studio31 keyboard
(bind-type Key <i64,i64,i64>)
; 0 pitchclass reference
; 1 octave
; 2 manual

(bind-func pitchclass:[i64,Key*]*
  (lambda (k)
    (tref k 0)))

(bind-func set_pitchclass:[void,Key*,i64]*
  (lambda (k pc)
    (tset! k 0 pc)
    void))

(bind-func octave:[i64,Key*]*
  (lambda (k)
    (tref k 1)))

(bind-func set_octave:[void,Key*,i64]*
  (lambda (k o)
    (tset! k 1 o)
    void))

(bind-func manual:[i64,Key*]*
  (lambda (k)
    (tref k 2)))

(bind-func set_manual:[void,Key*,i64]*
  (lambda (k m)
    (tset! k 2 m)
    void))

(bind-func set:[void,Key*,i64,i64,i64]*
  (lambda (k p o m)
    (tfill! k p o m)
    void))

(bind-func print:[void,Key*]*
  (lambda (k)
    (printf "Key: pitch = %lld, octave = %lld, manual = %lld\n"
            (pitchclass k)
            (octave k)
            (manual k))
    void))

(bind-func cKey:[Key*,i64,i64,i64]*
  (lambda (p o m)
    (let ((res (Key:[Key*,i64,i64,i64]* p o m)))
      res)))
      

; Notename* object, describes a pitch based on root, octave and alteration
(bind-type Notename <String*,i64,String*>)
; 0 root name (<step> element in xml data)
; 1 octave (following MIDI)
; 2 accidental

(bind-func root:[String*,Notename*]*
  (lambda (nn)
    (tref nn 0)))

(bind-func set_root:[void,Notename*,String*]*
  (lambda (nn r)
    (tset! nn 0 r)
    void))

(bind-func octave:[i64,Notename*]*
  (lambda (nn)
    (tref nn 1)))

(bind-func set_octave:[void,Notename*,i64]*
  (lambda (nn o)
    (tset! nn 1 o)
    void))

(bind-func accidental:[String*,Notename*]*
  (lambda (nn)
    (tref nn 2)))

(bind-func set_accidental:[void,Notename*,String*]*
  (lambda (nn a)
    (tset! nn 2 a)
    void))

(bind-func set:[void,Notename*,String*,i64,String*]*
  (lambda (nn r o a)
    (tfill! nn r o a)
    void))

(bind-func print:[void,Notename*]*
  (lambda (nn)
    (printf "Notename: root = '%s', octave = %lld, accidental = '%s'\n"
            (cstring (root nn))
            (octave nn)
            (cstring (accidental nn)))
    void))

(bind-func cNotename:[Notename*,String*,i64,String*]*
  (lambda (r o a)
    (let ((res (Notename:[Notename*,String*,i64,String*]* r o a)))
      res)))


; Tabulature* object, stores references from Notename* to Key*, usually read from a file
(bind-type Tabulature <i64,Notename**,Key**>)
; count
; notename array
; key array

(bind-func count:[i64,Tabulature*]*
  (lambda (t)
    (tref t 0)))

(bind-func set_count:[void,Tabulature*,i64]*
  (lambda (t c)
    (tset! t 0 c)
    void))

(bind-func get_notename:[Notename*,Tabulature*,i64]*
  (lambda (t index)
    (cond ((and (>= index 0) (< index (count t)))
            (tref t 1 index))
          (else (roll_error rollErr (Str "Roll, get_notename (Tabulature*): index out of range. Returned 'null', might crash everything.") ROLL_ERR_FLAG_FATAL ROLL_ERR_DEST_ALL)
          null))))

(bind-func get_key:[Key*,Tabulature*,i64]*
  (lambda (t index)
    (cond ((and (>= index 0) (< index (count t)))
            (tref t 2 index))
          (else (roll_error rollErr (Str "Roll, get_key (Tabulature*): index out of range. Returned 'null', might crash everything.") ROLL_ERR_FLAG_FATAL ROLL_ERR_DEST_ALL)
          null))))

(bind-func push:[void,Tabulature*,Notename*,Key*]*
  (lambda (tab nn k)
    (let ((tmpNotename:Notename** (halloc (+ 1 (count tab))))
          (tmpKey:Key** (halloc (+ 1 (count tab))))
          (i 0))
      (dotimes (i (count tab))
        (pset! tmpNotename i (get_notename tab i))
        (pset! tmpKey i (get_key tab i)))
      (free (tref tab 1))
      (free (tref tab 2))
      (pset! tmpNotename (count tab) nn)
      (pset! tmpKey (count tab) k)
      (set_count tab (+ (count tab) 1))
      void)))
      

(bind-func test
  (lambda ()
    (let ((nn (cNotename (Str "C") 2 (Str "flat")))
          (k (cKey 0 1 0))
          (t (cTabulature)))
      (push t nn k)
      (print (get_notename t 0)))))

($ (test))


(bind-func print:[void,Tabulature*]*
  (lambda (tab)
    (let ((i 0))
      (printf "Tabulature (count = %lld)\n" (count tab))
      (dotimes (i (count tab))
        (print (get_notename tab i))
        (print (get_key tab i)))
      void)))

(bind-func cTabulature:[Tabulature*]*
  (lambda ()
    (let ((tmpNotenames:Notename** (halloc 1))
          (tmpKeys:Key** (halloc 1)))
      (pset! tmpNotenames 0 null)
      (pset! tmpKeys 0 null)
      (let ((res (Tabulature:[Tabulature*,i64,Notename**,Key**]* 0 tmpNotenames tmpKeys)))
        res))))


; Config* object, stores all the configuration options for passes 2-5

(bind-type Config <Tabulature*>)
; 0 tabulature object, mapping between notated pitches and keys


