; XMLpair element, stores two strings, a first element, and the rest of the xml data
(bind-type XMLpair <String*,String*>)
; 0 xml data
; 1 xml data

(bind-func xml_car:[String*,XMLpair*]*
  (lambda (p)
    (tref p 0)))

(bind-func set_first:[void,XMLpair*,String*]*
  (lambda (p s)
    (tset! p 0 s)
    void))

(bind-func xml_cdr:[String*,XMLpair*]*
  (lambda (p)
    (tref p 1)))

(bind-func set_second:[void,XMLpair*,String*]*
  (lambda (p s)
    (tset! p 1 s)
    void))

(bind-func cXMLpair:[XMLpair*,String*,String*]*
  (lambda (first second)
    (let ((res (XMLpair:[XMLpair*,String*,String*]* first second)))
      res)))

(bind-func print:[void,XMLpair*]*
  (lambda (p)
    (printf "Pair: first = \n%s\nPair: second = \n%s\n"
            (cstring (xml_car p))
            (cstring (xml_cdr p)))
    void))



; XMLelement, stores the content of an xml element
(bind-type XMLelement <String*,i64,String**,String**,String*>)
; 0 name
; 1 attribute count
; 2 attribute names
; 3 attribute values
; 4 body

(bind-func name:[String*,XMLelement*]*
  (lambda (xmlElement)
    (tref xmlElement 0)))

(bind-func set_name:[void,XMLelement*,String*]*
  (lambda (xmlElement name)
    (tset! xmlElement 0 name)
    void))

(bind-func count:[i64,XMLelement*]*
  (lambda (xmlElement)
    (tref xmlElement 1)))

(bind-func set_count:[void,XMLelement*,i64]*
  (lambda (xmlElement count)
    (tset! xmlElement 1 count)
    void))

(bind-func attributeName:[String*,XMLelement*,i64]*
  (lambda (xmlElement index)
    (cond ((and (>= index 0) (< index (count xmlElement)))
            (pref (tref xmlElement 2) index))
          (else (roll_error rollErr
                            (Str "Roll, XMLelement:attributeName: index out of range.")
                            ROLL_ERR_FLAG_FATAL
                            ROLL_ERR_DEST_ALL)
                (Str "")))))

(bind-func attributeValue:[String*,XMLelement*,i64]*
  (lambda (xmlElement index)
    (cond ((and (>= index 0) (< index (count xmlElement)))
            (pref (tref xmlElement 3) index))
          (else (roll_error rollErr
                            (Str "Roll, XMLelement:attributeValue: index out of range.")
                            ROLL_ERR_FLAG_FATAL
                            ROLL_ERR_DEST_ALL)
                (Str "")))))

(bind-func attribute:[String*,XMLelement*,String*]*
  (lambda (xmlElement name)
    (let ((i 0)
          (res (Str "")))
      (dotimes (i (count xmlElement)) 
        (if (equal (attributeName xmlElement i) name)
          (set! res (attributeValue xmlElement i))))
      res)))





(bind-func body:[String*,XMLelement*]*
  (lambda (xmlElement)
    (tref xmlElement 4)))

(bind-func set_body:[void,XMLelement*,String*]*
  (lambda (xmlElement body)
    (tset! xmlElement 4 body)
    void))

(bind-func push_attribute:[void,XMLelement*,String*,String*]*
  (lambda (xmlElement name value)
    (let ((tmpNamePtr:String** (halloc (+ 1 (count xmlElement))))
          (tmpValuePtr:String** (halloc (+ 1 (count xmlElement))))
          (i 0))
      (dotimes (i (count xmlElement))
        (pset! tmpNamePtr i (attributeName xmlElement i))
        (pset! tmpValuePtr i (attributeValue xmlElement i)))
      (pset! tmpNamePtr (count xmlElement) name)
      (pset! tmpValuePtr (count xmlElement) value)
      (set_count xmlElement (+ 1 (count xmlElement)))
      (free (tref xmlElement 2))
      (free (tref xmlElement 3))
      (tset! xmlElement 2 tmpNamePtr)
      (tset! xmlElement 3 tmpValuePtr)
      void)))

(bind-func cXMLelement:[XMLelement*]*
  (lambda ()
    (let ((namePtr:String** (halloc 1))
          (valuePtr:String** (halloc 1)))
      (set! namePtr null)
      (set! valuePtr null)
      (let ((res (XMLelement:[XMLelement*,String*,i64,String**,String**,String*]*
                             (Str "")
                             0
                             namePtr
                             valuePtr
                             (Str ""))))
         res))))

(bind-func print:[void,XMLelement*]*
  (lambda (xmlElement)
    (printf "XML element:\nname = '%s'\n" (cstring (name xmlElement)))
    (let ((i 0))
      (dotimes (i (count xmlElement))
        (printf "attribute #%lld: name = '%s', value = '%s'\n"
                i
                (cstring (attributeName xmlElement i))
                (cstring (attributeValue xmlElement i))))
      (printf "body:\n%s\n" (cstring (body xmlElement)))
      void)))




; takes xml data, returns xml data with everything removed until a first occurrence of '<'
(bind-func xml_delete_until_left_bracket:[String*,String*]*
  (lambda (xmlData)
    (cond ((= 0 (length xmlData)) (Str ""))
          (else (split_second xmlData (find_substring xmlData (Str "<")))))))

; takes xml data, returns xml data without the '<?' element
(bind-func xml_skip_version_element:[String*,String*]*
  (lambda (xmlData)
    (xml_delete_until_left_bracket (split_second xmlData (+ 2 (find_substring xmlData (Str "?>")))))))

; takes xml data, returns xml data without the '<!' element
(bind-func xml_skip_doctype_element:[String*,String*]*
  (lambda (xmlData)
    (xml_delete_until_left_bracket (split_second xmlData (+ 1 (find_substring xmlData (Str ">")))))))

; takes xml data, returns a String* containing the name of the first xml element
(bind-func xml_extract_element_name:[String*,String*]*
  (lambda (xmlData)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_extract_element_name: empty xmlData pointer. Problem.")
                                       ROLL_ERR_FLAG_FATAL
                                       ROLL_ERR_DEST_ALL)
                           null)
          ((= 0 (length xmlData)) (Str ""))
          ((not (equal (substring xmlData 0 1) (Str "<"))) (roll_error rollErr
                                                           (Str "Roll, xml_extract_element_name: first character is not '<', can't parse.")
                                                           ROLL_ERR_FLAG_FATAL
                                                           ROLL_ERR_DEST_ALL)
                                                           (Str ""))
          (else (substring xmlData 1 (find_substring_or xmlData (Str " ") (Str ">")))))))

; takes a String* with a name (without '<>'), returns a String* with the corresponding endtag
(bind-func xml_construct_endtag:[String*,String*]*
  (lambda (name)
    (cat2 (cat2 (Str "</") name) (Str ">"))))

; takes xml data, returns the index of the second element on the highest level
(bind-func xml_find_element_separation:[i64,String*]*
  (lambda (xmlData)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_find_element_separation: undefined xmlData pointer. Problem.")
                                       ROLL_ERR_FLAG_FATAL
                                       ROLL_ERR_DEST_ALL)
                           0)
          ((= 0 (length xmlData)) 0)
          ((not (equal (substring xmlData 0 1) (Str "<"))) (roll_error rollErr (Str "Roll, xml_find_element_separation: first character is not a '<', stop parsing.")
                                                                               ROLL_ERR_FLAG_FATAL
                                                                               ROLL_ERR_DEST_ALL)
                                                           0)
          (else
            (let ((titleClose (find_substring xmlData (Str ">"))))
              ;DEBUG: (printf "titleClose=%lld\n" titleClose)
              (cond ((equal (substring xmlData (- titleClose 1) titleClose) (Str "/"))
                      (find_substring_from xmlData (Str "<") titleClose))
                    (else (let* ((name (xml_extract_element_name xmlData))
                                 (endtag (xml_construct_endtag name))
                                 (endPos (+ (find_substring xmlData endtag) (length endtag))))
                            ;DEBUG: (printf "name='%s', endtag='%s', endPos=%lld\n" (cstring name) (cstring endtag) endPos)
                            (find_substring_from xmlData (Str "<") endPos)))))))))

; takes xml data, returns a XMLpair, 'first' being the first xml element, 'second' being
; the rest of the xml data
(bind-func xml_divide:[XMLpair*,String*]*
  (lambda (xmlData)
    (cond ((not (equal (split_first xmlData 1) (Str "<")))
            (roll_error rollErr
                        (Str "xml_read_element: first character is not '<', malformed xmlData. This will abort the parsing process.")
                        ROLL_ERR_FLAG_FATAL
                        ROLL_ERR_DEST_ALL)
            null)
          (else
            (let ((splitPoint (xml_find_element_separation xmlData)))
              ;DEBUG: (printf "splitpoint: %lld\n" splitPoint)
              (cond ((<= splitPoint 0)
                      (let ((res (cXMLpair xmlData (Str "")))) 
                        res))
                    (else
                      (let ((res (cXMLpair (split_first xmlData splitPoint) (split_second xmlData splitPoint))))
                        res))))))))

; takes a String* with the title data of an xml element (< ... >) and an XMLelement*,
; extracts the attribute names and values and stores them in the XMLelement*
(bind-func xml_extract_attribute:[void,String*,XMLelement*]*
  (lambda (xmlData xmlElement)
    (cond ((null? xmlData) void)
          ((= 0 (length xmlData)) void)
          (else (let ((name (split_first xmlData (find_substring xmlData (Str "="))))
                      (value (substring xmlData (+ 2 (find_substring xmlData (Str "=")))
                                                (find_substring_from xmlData (create_quotes) (+ 1 (find_substring xmlData (create_quotes))))))
                      (leftover (split_second xmlData (+ 4 (length name) (length value)))))
                  (push_attribute xmlElement name value)
                  (xml_extract_attribute leftover xmlElement))))))

; takes a String* starting with the body of an element, a XMLelement* and a String* with
; the name of the element; extracts the body and stores it in the XMLelement*
(bind-func xml_extract_body:[void,String*,XMLelement*,String*]*
  (lambda (xmlData xmlElement endtag)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_extract_body: empty xmlData pointer. Did nothing.")
                                       ROLL_ERR_FLAG_WARNING
                                       ROLL_ERR_DEST_ALL)
                           void)
          ((= 0 (length xmlData)) void)
          (else (set_body xmlElement (remove_initial_spaces (split_first xmlData (find_substring xmlData endtag))))
                void))))

; takes xml data and an XMLelement*, extracts name, attributes and body and stores this
; data in the XMLelement*
(bind-func xml_read_element:[void,String*,XMLelement*]*
  (lambda (xmlData xmlElement)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_read_element: empty xmlData pointer. Did nothing.")
                                       ROLL_ERR_FLAG_WARNING
                                       ROLL_ERR_DEST_ALL)
                           void)
          ((= 0 (length xmlData)) void)
          ((not (equal (substring xmlData 0 1) (Str "<"))) (roll_error rollErr
                                                             (Str "Roll, xml_read_element: first character is not '<'.  Problem?")
                                                             ROLL_ERR_FLAG_WARNING
                                                             ROLL_ERR_DEST_ALL)
                                                           void)
          ((equal (substring xmlData (- (find_substring xmlData (Str ">")) 1) (find_substring xmlData (Str ">"))) (Str "/"))
            (set_name xmlElement (substring xmlData 1 (find_substring_or xmlData (Str " ") (Str "/"))))
            ; DEBUG: (printf "wohooooooo: name = '%s'\nattributes = '%s'\n" (cstring (name xmlElement)) (cstring (substring xmlData (+ (length (name xmlElement)) 2) (find_substring xmlData (Str "/")))))
            (xml_extract_attribute (substring xmlData (+ (length (name xmlElement)) 2) (find_substring xmlData (Str "/"))) xmlElement))
          (else 
            (let ((name (xml_extract_element_name xmlData)))
              (set_name xmlElement name)
              (xml_extract_attribute (substring xmlData (+ 2 (length name)) (find_substring xmlData (Str ">"))) xmlElement)
              (xml_extract_body (split_second xmlData (+ 1 (find_substring xmlData (Str ">")))) xmlElement (xml_construct_endtag name))
              void)))))



; ParserState remembers things while reading through xml Data
(bind-type ParserState <i64,i64,i64,i64,i64,String*,i64,i64,i1,i64,i64,String*,float,i1,String*,String*,String*,String*,String*,i64>)
; 0 part count
; 1 measure count
; 2 divisions
; 3 beats (meter numerator)
; 4 beat-type (meter denominator)
; 5 step (note name)
; 6 octave
; 7 duration
; 8 rest
; 9 timer (within measure)
; 10 note count
; 11 accidental
; 12 alter
; 13 chord
; 14 tie (string)
; 15 parent (name of enclosing xml element)
; 16 notehead
; 17 articulation
; 18 text
; 19 xml voice assignment

(bind-func partCount:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 0)))

(bind-func set_partCount:[void,ParserState*,i64]*
  (lambda (ps pc)
    (tset! ps 0 pc)
    void))

(bind-func measureCount:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 1)))

(bind-func set_measureCount:[void,ParserState*,i64]*
  (lambda (ps mc)
    (tset! ps 1 mc)
    void))

(bind-func divisions:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 2)))

(bind-func set_divisions:[void,ParserState*,i64]*
  (lambda (ps d)
    (tset! ps 2 d)
    void))
    
(bind-func beats:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 3)))

(bind-func set_beats:[void,ParserState*,i64]*
  (lambda (ps b)
    (tset! ps 3 b)
    void))

(bind-func beatType:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 4)))

(bind-func set_beatType:[void,ParserState*,i64]*
  (lambda (ps bt)
    (tset! ps 4 bt)
    void))

(bind-func step:[String*,ParserState*]*
  (lambda (ps)
    (tref ps 5)))

(bind-func set_step:[void,ParserState*,String*]*
  (lambda (ps s)
    (tset! ps 5 s)
    void))

(bind-func octave:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 6)))

(bind-func set_octave:[void,ParserState*,i64]*
  (lambda (ps o)
    (tset! ps 6 o)
    void))

(bind-func duration:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 7)))

(bind-func set_duration:[void,ParserState*,i64]*
  (lambda (ps d)
    (tset! ps 7 d)
    void))

(bind-func rest:[i1,ParserState*]*
  (lambda (ps)
    (tref ps 8)))

(bind-func set_rest:[void,ParserState*,i1]*
  (lambda (ps r)
    (tset! ps 8 r)
    void))

(bind-func timer:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 9)))

(bind-func set_timer:[void,ParserState*,i64]*
  (lambda (ps t)
    (tset! ps 9 t)
    void))

(bind-func noteCount:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 10)))

(bind-func set_noteCount:[void,ParserState*,i64]*
  (lambda (ps nc)
    (tset! ps 10 nc)
    void))

(bind-func accidental:[String*,ParserState*]*
  (lambda (ps)
    (tref ps 11)))

(bind-func set_accidental:[void,ParserState*,String*]*
  (lambda (ps a)
    (tset! ps 11 a)
    void))

(bind-func alter:[float,ParserState*]*
  (lambda (ps)
    (tref ps 12)))

(bind-func set_alter:[void,ParserState*,float]*
  (lambda (ps a)
    (tset! ps 12 a)
    void))

(bind-func chord:[i1,ParserState*]*
  (lambda (ps)
    (tref ps 13)))

(bind-func set_chord:[void,ParserState*,i1]*
  (lambda (ps c)
    (tset! ps 13 c)
    void))

(bind-func tie:[String*,ParserState*]*
  (lambda (ps)
    (tref ps 14)))

(bind-func set_tie:[void,ParserState*,String*]*
  (lambda (ps t)
    (tset! ps 14 t)
    void))

(bind-func parent:[String*,ParserState*]*
  (lambda (ps)
    (tref ps 15)))

(bind-func set_parent:[void,ParserState*,String*]*
  (lambda (ps p)
    (tset! ps 15 p)
    void))

(bind-func notehead:[String*,ParserState*]*
  (lambda (ps)
    (tref ps 16)))
    
(bind-func set_notehead:[void,ParserState*,String*]*
  (lambda (ps nh)
    (tset! ps 16 nh)
    void))

(bind-func articulation:[String*,ParserState*]*
  (lambda (ps)
    (tref ps 17)))

(bind-func set_articulation:[void,ParserState*,String*]*
  (lambda (ps a)
    (tset! ps 17 a)
    void))

(bind-func text:[String*,ParserState*]*
  (lambda (ps)
    (tref ps 18)))

(bind-func set_text:[void,ParserState*,String*]*
  (lambda (ps t)
    (tset! ps 18 t)
    void))

(bind-func xmlVoice:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 19)))

(bind-func set_xmlVoice:[void,ParserState*,i64]*
  (lambda (ps v)
    (tset! ps 19 v)
    void))

(bind-func cParserState:[ParserState*]*
  (lambda ()
    (let ((res (ParserState:[ParserState*,i64,i64,i64,i64,i64,String*,i64,i64,i1,i64,i64,String*,float,i1,String*,String*,String*,String*,String*,i64]* 
                            0 
                            0
                            0
                            0
                            0
                            (Str "")
                            0
                            0
                            #f
                            0
                            0
                            (Str "")
                            0.0
                            #f
                            (Str "")
                            (Str "")
                            (Str "")
                            (Str "")
                            (Str "")
                            0)))
          res)))

(bind-func print:[void,ParserState*]*
  (lambda (state)
    (printf "Parser state printout:\npart count = %lld\nmeasure count = %lld\ndivisions =
    %lld\nbeats = %lld\nbeatType = %lld\nrest = %s\ntimer = %lld\nstep = '%s'\noctave =
    %lld\nduration = %lld\nnoteCount = %lld\naccidental = '%s'\nalter = %f\nchord =
    %s\ntie = '%s'\nparent = '%s'\nnotehead = '%s'\narticulation = '%s'\ntext = '%s'\nxml
    %voice = %lld\n"
            (partCount state)
            (measureCount state)
            (divisions state)
            (beats state)
            (beatType state)
            (if (rest state) "yes" "no")
            (timer state)
            (cstring (step state))
            (octave state)
            (duration state)
            (noteCount state)
            (cstring (accidental state))
            (ftod (alter state))
            (if (chord state) "yes" "no")
            (cstring (tie state))
            (cstring (parent state))
            (cstring (notehead state))
            (cstring (articulation state))
            (cstring (text state))
            (xmlVoice state))
    void))


; transform time value in 'local ticks' (<divisions> of <measure>) into 'global ticks'
(bind-func recalculate_time:[i64,i64,i64,i64]*
  (lambda (value globalDivision localDivision)
     (* (/ value localDivision) globalDivision)))


; dummy, for compilation
(bind-func xml_parse:[void,String*,Score*,ParserState*]* (lambda (a b c) void))

; central parser unit: takes an XMLelement* storage, a Score* storage and a ParserState*
; storage and reads through the data while filling the Score* object. the final product is
; a complete Score* object
(bind-func xml_interpret_element:[void,XMLelement*,Score*,ParserState*]*
  (lambda (xmlElement score state)
    (cond ((equal (name xmlElement) (Str "score-partwise"))
            (roll_error rollErr (Str "Parser: partwise score detected.") ROLL_ERR_FLAG_INFO ROLL_ERR_DEST_ALL)
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "part"))
            (roll_error rollErr (cat2 (cat2 (Str "Parser: opening part '") (attribute xmlElement (Str "id"))) (Str "'."))
                                ROLL_ERR_FLAG_INFO ROLL_ERR_DEST_ALL)
            (set_partCount state (+ 1 (partCount state)))
            (set_measureCount state 0)
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "measure"))
            ; push a new measure into Score*
            (set_measureCount state (+ 1 (measureCount state)))
            (if (< (measureCount score) (measureCount state))
              (begin (push score (cMeasure))
                     (set_number (get_measure score (- (measureCount score) 1)) (measureCount state))
                     (set_noteCount state 0))
              (begin (set_noteCount state (- (noteCount (get_measure score (- (measureCount state) 1))) 0))))
            ; reset measure specific state values
            (set_timer state 0)
            ; ...
            ; read body of <measure>
            (xml_parse (body xmlElement) score state)
            (set_division (get_measure score (- (measureCount state) 1)) (divisions state)))
          ((equal (name xmlElement) (Str "attributes"))
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "divisions"))
            (set_divisions state (extract_i64 (body xmlElement))))
          ((equal (name xmlElement) (Str "time"))
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "beats"))
            (set_beats state (extract_i64 (body xmlElement))))
          ((equal (name xmlElement) (Str "beat-type"))
            (set_beatType state (extract_i64 (body xmlElement))))
          ((equal (name xmlElement) (Str "note"))
            ; reset note specific data:
            (set_step state (Str ""))
            (set_octave state 0)
            (set_duration state 0)
            (set_rest state #f)
            (set_accidental state (Str ""))
            (set_alter state 0.0)
            (set_chord state #f)
            (set_tie state (Str ""))
            (set_notehead state (Str "normal"))
            (set_articulation state (Str "normal"))
            (set_text state (Str "x"))
            (set_xmlVoice state 0)
            ; read body of <note>:
            (set_parent state (name xmlElement))
            (xml_parse (body xmlElement) score state)
            ; act on data in ParserState*:
            ;   in case chord is true, set timer to starttime of previous note
            (if (chord state)
              (set_timer state (startTime (get_note (get_measure score (- (measureCount state) 1)) (- (noteCount state) 1)))))
            ;   in case rest is false, push a new note into score and fill with data
            ;      (rests are not written into Score*)
            (if (not (rest state))
              (let ((currentMeasure (get_measure score (- (measureCount state) 1))))
                (push currentMeasure (cNote))
                (set_noteCount state (+ (noteCount state) 1))
                (let ((currentNote (get_note currentMeasure (- (noteCount state) 1))))
                  ; write note specific data into score:
                  (set_startTime currentNote (timer state))
                  (set_root currentNote (step state))
                  (set_octave currentNote (octave state))
                  (set_duration currentNote (duration state))
                  (set_accidental currentNote (accidental state))
                  (set_alter currentNote (alter state))
                  (cond ((equal (tie state) (Str "")) (set_tie currentNote ROLL_TIE_NONE))
                        ((equal (tie state) (Str "start")) (set_tie currentNote ROLL_TIE_START))
                        ((equal (tie state) (Str "stop")) (set_tie currentNote ROLL_TIE_END))
                        ((equal (tie state) (Str "both")) (set_tie currentNote ROLL_TIE_WITHIN))
                        (else (set_tie currentNote -1)))
                  (set_part currentNote (- (partCount state) 1))
                  (set_notehead currentNote (notehead state))
                  (set_articulation currentNote (articulation state))
                  (set_xmlVoice currentNote (xmlVoice state))
                  (if (not (equal (text state) (Str "x")))
                    (begin 
                    ; to be reworked!
                    (printf "wohohooooo\n")
                    (cond ((equal (substring (text state) 0 1) (Str "!"))
                            (set_command currentNote (split_second (text state) 1)))
                          ((equal (substring (text state) 0 1) (Str "p"))
                            (set_pitchInfo currentNote (text state)))  
                          (else (roll_error rollErr (Str "Roll, xml_parse: textfield prefix unknown.") ROLL_ERR_FLAG_WARNING ROLL_ERR_DEST_ALL)))))
                  ; ...
                  void)))
            ; update time
            (set_timer state (+ (timer state) (duration state)))
            void)
          ((equal (name xmlElement) (Str "pitch"))
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "rest"))
            (set_rest state #t))
          ((equal (name xmlElement) (Str "chord"))
            (set_chord state #t))
          ((equal (name xmlElement) (Str "tie"))
            (cond ((and (equal (tie state) (Str "stop"))
                        (equal (attribute xmlElement (Str "type")) (Str "start")))
                    (set_tie state (Str "both")))
                  ((and (equal (tie state) (Str "start"))
                        (equal (attribute xmlElement (Str "type")) (Str "stop")))
                    (set_tie state (Str "both")))
                  (else (set_tie state (attribute xmlElement (Str "type"))))))
          ((equal (name xmlElement) (Str "step"))
            (set_step state (body xmlElement)) void)
          ((equal (name xmlElement) (Str "voice"))
            (set_xmlVoice state (extract_i64 (body xmlElement))))
          ((equal (name xmlElement) (Str "octave"))
            (set_octave state (extract_i64 (body xmlElement))))
          ((equal (name xmlElement) (Str "duration"))
            (cond ((equal (parent state) (Str "note"))
                    ; DEBUG: (printf "duration detected and extracted! %lld\n" (extract_i64 (body xmlElement)))
                    (set_duration state (recalculate_time (extract_i64 (body xmlElement)) (division score) (divisions state))))
                  ((equal (parent state) (Str "backup"))
                    (set_timer state (- (timer state) (recalculate_time (extract_i64 (body xmlElement)) (division score) (divisions state)))))
                  ((equal (parent state) (Str "forward"))
                    (set_timer state (+ (timer state) (recalculate_time (extract_i64 (body xmlElement)) (division score) (divisions state)))))
                  (else (roll_error rollErr (Str "Roll, xml_parse: unknown parent of <duration>.") ROLL_ERR_FLAG_WARNING ROLL_ERR_DEST_ALL)) void))
          ((equal (name xmlElement) (Str "accidental"))
            (set_accidental state (body xmlElement)))
          ((equal (name xmlElement) (Str "notehead"))
            (set_notehead state (body xmlElement)))
          ((equal (name xmlElement) (Str "articulations"))
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "notations"))
            (xml_parse (body xmlElement) score state))
          ((or (equal (name xmlElement) (Str "tenuto"))
               (equal (name xmlElement) (Str "staccato"))
               (equal (name xmlElement) (Str "accent")))
            (if (equal (articulation state) (Str "normal"))
              (set_articulation state (name xmlElement))
              (set_articulation state (cat2 (articulation state) (name xmlElement)))))
          ((equal (name xmlElement) (Str "alter"))
            (set_alter state (extract_float (body xmlElement))))
          ((equal (name xmlElement) (Str "backup"))
            (set_parent state (name xmlElement))
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "forward"))
            (set_parent state (name xmlElement))
            (xml_parse (body xmlElement) score state))
          (else 
               ; (roll_error rollErr
               ;             (cat2 (cat2 (Str "Roll, xml_interpret_element: ignoring element '") (name xmlElement)) (Str "' and its content and sub-elements."))
               ;             ROLL_ERR_FLAG_INFO
               ;             ROLL_ERR_DEST_ALL))
               void)
                void)))



(bind-func xml_parse:[void,String*,Score*,ParserState*]*
  (lambda (xmlData score state)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_parse: undefined xmlData pointer.  No parsing possible.")
                                       ROLL_ERR_FLAG_FATAL
                                       ROLL_ERR_DEST_ALL)
                           void)
          ((= 0 (length xmlData)) void)
          (else
            (let ((first (substring xmlData 0 2)))
              (cond ((equal first (Str "<?"))
                      ;DEBUG: (printf "xmlData:\n%s\n" (cstring (xml_skip_version_element xmlData)))
                      (xml_parse (xml_skip_version_element xmlData) score state))
                    ((equal first (Str "<!"))
                      ;DEBUG: ;(printf "xmlData:\n%s\n" (cstring (xml_skip_doctype_element xmlData)))
                      (xml_parse (xml_skip_doctype_element xmlData) score state))
                    (else 
                      (let ((pair (xml_divide xmlData))
                            (xmlElement (cXMLelement)))
                        ;DEBUG: (print pair)
                        (xml_read_element (xml_car pair) xmlElement)
                        (xml_interpret_element xmlElement score state)
                        (xml_parse (xml_cdr pair) score state)))))))))
        






; dummy, for compiler
(bind-func xml_pre_parse:[void,String*,i64*,i64*]* (lambda (a b c) void))

; reads through xml data to extract all <divisions> elements in order to determine the highest
(bind-func xml_pre_interpret_element:[void,XMLelement*,i64*,i64*]*
  (lambda (xmlElement maxDivision currentDivision)
    (cond ((equal (name xmlElement) (Str "score-partwise"))
            (roll_error rollErr (Str "Parser: partwise score detected.") ROLL_ERR_FLAG_INFO ROLL_ERR_DEST_ALL)
            (xml_pre_parse (body xmlElement) maxDivision currentDivision))
          ((equal (name xmlElement) (Str "part"))
            (roll_error rollErr (cat2 (cat2 (Str "Parser: opening part '") (attribute xmlElement (Str "id"))) (Str "'."))
                                ROLL_ERR_FLAG_INFO ROLL_ERR_DEST_ALL)
            (xml_pre_parse (body xmlElement) maxDivision currentDivision))
          ((equal (name xmlElement) (Str "measure"))
            (pset! currentDivision 0 0)
            (xml_pre_parse (body xmlElement) maxDivision currentDivision)
            (if (> (pref currentDivision 0) (pref maxDivision 0))
              (begin 
                (pset! maxDivision 0 (pref currentDivision 0))
                void)))
          ((equal (name xmlElement) (Str "attributes"))
            (xml_pre_parse (body xmlElement) maxDivision currentDivision))
          ((equal (name xmlElement) (Str "divisions"))
            (pset! currentDivision 0 (extract_i64 (body xmlElement)))
            void)
          (else 
               ; (roll_error rollErr
               ;             (cat2 (cat2 (Str "Roll, xml_interpret_element: ignoring element '") (name xmlElement)) (Str "' and its content and sub-elements."))
               ;             ROLL_ERR_FLAG_INFO
               ;             ROLL_ERR_DEST_ALL))
               void))
                void))

; scans the xml score for all measure divisions, writes highest value in maxDivision
(bind-func xml_pre_parse:[void,String*,i64*,i64*]*
  (lambda (xmlData maxDivision currentDivision)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_pre_parse: undefined xmlData pointer.  No parsing possible.")
                                       ROLL_ERR_FLAG_FATAL
                                       ROLL_ERR_DEST_ALL)
                           void)
          ((= 0 (length xmlData)) void)
          (else
            (let ((first (substring xmlData 0 2)))
              (cond ((equal first (Str "<?"))
                      ;DEBUG: (printf "xmlData:\n%s\n" (cstring (xml_skip_version_element xmlData)))
                      (xml_pre_parse (xml_skip_version_element xmlData) maxDivision currentDivision))
                    ((equal first (Str "<!"))
                      ;DEBUG: ;(printf "xmlData:\n%s\n" (cstring (xml_skip_doctype_element xmlData)))
                      (xml_pre_parse (xml_skip_doctype_element xmlData) maxDivision currentDivision))
                    (else 
                      (let ((pair (xml_divide xmlData))
                            (xmlElement (cXMLelement)))
                        ;DEBUG: (print pair)
                        (xml_read_element (xml_car pair) xmlElement)
                        (xml_pre_interpret_element xmlElement maxDivision currentDivision)
                        (xml_pre_parse (xml_cdr pair) maxDivision currentDivision)))))))))
    





(bind-func xml_import:[void,Score*,String*]*
  (lambda (score filepath)
    (let ((xmlFile (Str (sys_slurp_file (cstring filepath)))))
      (cond
        ((null? xmlFile) (roll_error rollErr
                                     (Str "Roll, xml_import: xml file could not be opened. Aborting.")
                                     ROLL_ERR_FLAG_FATAL
                                     ROLL_ERR_DEST_ALL)
                         void)
        ((= 0 (length xmlFile)) (roll_error rollErr
                                            (Str "Roll, xml_import: xml data empty. No parsing.")
                                            ROLL_ERR_FLAG_FATAL
                                            ROLL_ERR_DEST_ALL))
        (else
          (let ((maxDivision:i64* (salloc 1))
                (currentDivision:i64* (salloc 1))
                (state (cParserState)))
            (pset! maxDivision 0 0)
            (pset! currentDivision 0 0)
            (roll_error rollErr
                        (Str "XML file slurped.")
                        ROLL_ERR_FLAG_INFO
                        ROLL_ERR_DEST_ALL)
            ;DEBUG: (printf "file contents:\n%s\n" (cstring xmlFile))
            (xml_pre_parse xmlFile maxDivision currentDivision)
            (set_division score (pref maxDivision 0))
            (roll_error rollErr (Str "Pre parse done: score division = ") ROLL_ERR_FLAG_INFO ROLL_ERR_DEST_ALL)
            (xml_parse xmlFile score state)
            ;DEBUG: (printf "this went well.\n")
            ;DEBUG: (print state)
            void)))
    void)))
