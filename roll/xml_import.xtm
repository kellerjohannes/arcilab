; XMLpair element, stores two strings, a first element, and the rest of the xml data
(bind-type XMLpair <String*,String*>)
; 0 xml data
; 1 xml data

(bind-func xml_car:[String*,XMLpair*]*
  (lambda (p)
    (tref p 0)))

(bind-func set_first:[void,XMLpair*,String*]*
  (lambda (p s)
    (tset! p 0 s)
    void))

(bind-func xml_cdr:[String*,XMLpair*]*
  (lambda (p)
    (tref p 1)))

(bind-func set_second:[void,XMLpair*,String*]*
  (lambda (p s)
    (tset! p 1 s)
    void))

(bind-func cXMLpair:[XMLpair*,String*,String*]*
  (lambda (first second)
    (let ((res (XMLpair:[XMLpair*,String*,String*]* first second)))
      res)))

(bind-func print:[void,XMLpair*]*
  (lambda (p)
    (printf "Pair: first = \n%s\nPair: second = \n%s\n"
            (cstring (xml_car p))
            (cstring (xml_cdr p)))
    void))



; XMLelement, stores the content of an xml element
(bind-type XMLelement <String*,i64,String**,String**,String*>)
; 0 name
; 1 attribute count
; 2 attribute names
; 3 attribute values
; 4 body

(bind-func name:[String*,XMLelement*]*
  (lambda (xmlElement)
    (tref xmlElement 0)))

(bind-func set_name:[void,XMLelement*,String*]*
  (lambda (xmlElement name)
    (tset! xmlElement 0 name)
    void))

(bind-func count:[i64,XMLelement*]*
  (lambda (xmlElement)
    (tref xmlElement 1)))

(bind-func set_count:[void,XMLelement*,i64]*
  (lambda (xmlElement count)
    (tset! xmlElement 1 count)
    void))

(bind-func attributeName:[String*,XMLelement*,i64]*
  (lambda (xmlElement index)
    (cond ((and (>= index 0) (< index (count xmlElement)))
            (pref (tref xmlElement 2) index))
          (else (roll_error rollErr
                            (Str "Roll, XMLelement:attributeName: index out of range.")
                            ROLL_ERR_FLAG_FATAL
                            ROLL_ERR_DEST_ALL)
                (Str "")))))

(bind-func attributeValue:[String*,XMLelement*,i64]*
  (lambda (xmlElement index)
    (cond ((and (>= index 0) (< index (count xmlElement)))
            (pref (tref xmlElement 3) index))
          (else (roll_error rollErr
                            (Str "Roll, XMLelement:attributeValue: index out of range.")
                            ROLL_ERR_FLAG_FATAL
                            ROLL_ERR_DEST_ALL)
                (Str "")))))

(bind-func attribute:[String*,XMLelement*,String*]*
  (lambda (xmlElement name)
    (let ((i 0)
          (res (Str "")))
      (dotimes (i (count xmlElement)) 
        (if (equal (attributeName xmlElement i) name)
          (set! res (attributeValue xmlElement i))))
      res)))





(bind-func body:[String*,XMLelement*]*
  (lambda (xmlElement)
    (tref xmlElement 4)))

(bind-func set_body:[void,XMLelement*,String*]*
  (lambda (xmlElement body)
    (tset! xmlElement 4 body)
    void))

(bind-func push_attribute:[void,XMLelement*,String*,String*]*
  (lambda (xmlElement name value)
    (let ((tmpNamePtr:String** (halloc (+ 1 (count xmlElement))))
          (tmpValuePtr:String** (halloc (+ 1 (count xmlElement))))
          (i 0))
      (dotimes (i (count xmlElement))
        (pset! tmpNamePtr i (attributeName xmlElement i))
        (pset! tmpValuePtr i (attributeValue xmlElement i)))
      (pset! tmpNamePtr (count xmlElement) name)
      (pset! tmpValuePtr (count xmlElement) value)
      (set_count xmlElement (+ 1 (count xmlElement)))
      (free (tref xmlElement 2))
      (free (tref xmlElement 3))
      (tset! xmlElement 2 tmpNamePtr)
      (tset! xmlElement 3 tmpValuePtr)
      void)))

(bind-func cXMLelement:[XMLelement*]*
  (lambda ()
    (let ((namePtr:String** (halloc 1))
          (valuePtr:String** (halloc 1)))
      (set! namePtr null)
      (set! valuePtr null)
      (let ((res (XMLelement:[XMLelement*,String*,i64,String**,String**,String*]*
                             (Str "")
                             0
                             namePtr
                             valuePtr
                             (Str ""))))
         res))))

(bind-func print:[void,XMLelement*]*
  (lambda (xmlElement)
    (printf "XML element:\nname = '%s'\n" (cstring (name xmlElement)))
    (let ((i 0))
      (dotimes (i (count xmlElement))
        (printf "attribute #%lld: name = '%s', value = '%s'\n"
                i
                (cstring (attributeName xmlElement i))
                (cstring (attributeValue xmlElement i))))
      (printf "body:\n%s\n" (cstring (body xmlElement)))
      void)))




; takes xml data, returns xml data with everything removed until a first occurrence of '<'
(bind-func xml_delete_until_left_bracket:[String*,String*]*
  (lambda (xmlData)
    (cond ((= 0 (length xmlData)) (Str ""))
          (else (split_second xmlData (find_substring xmlData (Str "<")))))))

; takes xml data, returns xml data without the '<?' element
(bind-func xml_skip_version_element:[String*,String*]*
  (lambda (xmlData)
    (xml_delete_until_left_bracket (split_second xmlData (+ 2 (find_substring xmlData (Str "?>")))))))

; takes xml data, returns xml data without the '<!' element
(bind-func xml_skip_doctype_element:[String*,String*]*
  (lambda (xmlData)
    (xml_delete_until_left_bracket (split_second xmlData (+ 1 (find_substring xmlData (Str ">")))))))

; takes xml data, returns a String* containing the name of the first xml element
(bind-func xml_extract_element_name:[String*,String*]*
  (lambda (xmlData)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_extract_element_name: empty xmlData pointer. Problem.")
                                       ROLL_ERR_FLAG_FATAL
                                       ROLL_ERR_DEST_ALL)
                           null)
          ((= 0 (length xmlData)) (Str ""))
          ((not (equal (substring xmlData 0 1) (Str "<"))) (roll_error rollErr
                                                           (Str "Roll, xml_extract_element_name: first character is not '<', can't parse.")
                                                           ROLL_ERR_FLAG_FATAL
                                                           ROLL_ERR_DEST_ALL)
                                                           (Str ""))
          (else (substring xmlData 1 (find_substring_or xmlData (Str " ") (Str ">")))))))

; takes a String* with a name (without '<>'), returns a String* with the corresponding endtag
(bind-func xml_construct_endtag:[String*,String*]*
  (lambda (name)
    (cat2 (cat2 (Str "</") name) (Str ">"))))

; takes xml data, returns the index of the second element on the highest level
(bind-func xml_find_element_separation:[i64,String*]*
  (lambda (xmlData)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_find_element_separation: undefined xmlData pointer. Problem.")
                                       ROLL_ERR_FLAG_FATAL
                                       ROLL_ERR_DEST_ALL)
                           0)
          ((= 0 (length xmlData)) 0)
          ((not (equal (substring xmlData 0 1) (Str "<"))) (roll_error rollErr (Str "Roll, xml_find_element_separation: first character is not a '<', stop parsing.")
                                                                               ROLL_ERR_FLAG_FATAL
                                                                               ROLL_ERR_DEST_ALL)
                                                           0)
          (else
            (let ((titleClose (find_substring xmlData (Str ">"))))
              ;DEBUG: (printf "titleClose=%lld\n" titleClose)
              (cond ((equal (substring xmlData (- titleClose 1) titleClose) (Str "/"))
                      (find_substring_from xmlData (Str "<") titleClose))
                    (else (let* ((name (xml_extract_element_name xmlData))
                                 (endtag (xml_construct_endtag name))
                                 (endPos (+ (find_substring xmlData endtag) (length endtag))))
                            ;DEBUG: (printf "name='%s', endtag='%s', endPos=%lld\n" (cstring name) (cstring endtag) endPos)
                            (find_substring_from xmlData (Str "<") endPos)))))))))

; takes xml data, returns a XMLpair, 'first' being the first xml element, 'second' being
; the rest of the xml data
(bind-func xml_divide:[XMLpair*,String*]*
  (lambda (xmlData)
    (cond ((not (equal (split_first xmlData 1) (Str "<")))
            (roll_error rollErr
                        (Str "xml_read_element: first character is not '<', malformed xmlData. This will abort the parsing process.")
                        ROLL_ERR_FLAG_FATAL
                        ROLL_ERR_DEST_ALL)
            null)
          (else
            (let ((splitPoint (xml_find_element_separation xmlData)))
              ;DEBUG: (printf "splitpoint: %lld\n" splitPoint)
              (cond ((<= splitPoint 0)
                      (let ((res (cXMLpair xmlData (Str "")))) 
                        res))
                    (else
                      (let ((res (cXMLpair (split_first xmlData splitPoint) (split_second xmlData splitPoint))))
                        res))))))))

; takes a String* with the title data of an xml element (< ... >) and an XMLelement*,
; extracts the attribute names and values and stores them in the XMLelement*
(bind-func xml_extract_attribute:[void,String*,XMLelement*]*
  (lambda (xmlData xmlElement)
    (cond ((null? xmlData) void)
          ((= 0 (length xmlData)) void)
          (else (let ((name (split_first xmlData (find_substring xmlData (Str "="))))
                      (value (substring xmlData (+ 2 (find_substring xmlData (Str "=")))
                                                (find_substring_from xmlData (create_quotes) (+ 1 (find_substring xmlData (create_quotes))))))
                      (leftover (split_second xmlData (+ 4 (length name) (length value)))))
                  (push_attribute xmlElement name value)
                  (xml_extract_attribute leftover xmlElement))))))

; takes a String* starting with the body of an element, a XMLelement* and a String* with
; the name of the element; extracts the body and stores it in the XMLelement*
(bind-func xml_extract_body:[void,String*,XMLelement*,String*]*
  (lambda (xmlData xmlElement endtag)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_extract_body: empty xmlData pointer. Did nothing.")
                                       ROLL_ERR_FLAG_WARNING
                                       ROLL_ERR_DEST_ALL)
                           void)
          ((= 0 (length xmlData)) void)
          (else (set_body xmlElement (remove_initial_spaces (split_first xmlData (find_substring xmlData endtag))))
                void))))

; takes xml data and an XMLelement*, extracts name, attributes and body and stores this
; data in the XMLelement*
(bind-func xml_read_element:[void,String*,XMLelement*]*
  (lambda (xmlData xmlElement)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_read_element: empty xmlData pointer. Did nothing.")
                                       ROLL_ERR_FLAG_WARNING
                                       ROLL_ERR_DEST_ALL)
                           void)
          ((= 0 (length xmlData)) void)
          ((not (equal (substring xmlData 0 1) (Str "<"))) (roll_error rollErr
                                                             (Str "Roll, xml_read_element: first character is not '<'.  Problem?")
                                                             ROLL_ERR_FLAG_WARNING
                                                             ROLL_ERR_DEST_ALL)
                                                           void)
          ((equal (substring xmlData (- (find_substring xmlData (Str ">")) 1) (find_substring xmlData (Str ">"))) (Str "/"))
            (set_name xmlElement (substring xmlData 1 (find_substring_or xmlData (Str " ") (Str "/")))))
          (else 
            (let ((name (xml_extract_element_name xmlData)))
              (set_name xmlElement name)
              (xml_extract_attribute (substring xmlData (+ 2 (length name)) (find_substring xmlData (Str ">"))) xmlElement)
              (xml_extract_body (split_second xmlData (+ 1 (find_substring xmlData (Str ">")))) xmlElement (xml_construct_endtag name))
              void)))))



; ParserState remembers things while reading through xml Data
(bind-type ParserState <i64,i64,i64*,i64*,i64*,String*,i64*,i64*,i1>)
; 0 part count
; 1 measure count
; 2 divisions
; 3 beats (meter numerator)
; 4 beat-type (meter denominator)
; 5 step (note name)
; 6 octave
; 7 duration
; 8 rest

(bind-func partCount:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 0)))

(bind-func set_partCount:[void,ParserState*,i64]*
  (lambda (ps pc)
    (tset! ps 0 pc)
    void))

(bind-func measureCount:[i64,ParserState*]*
  (lambda (ps)
    (tref ps 1)))

(bind-func set_measureCount:[void,ParserState*,i64]*
  (lambda (ps mc)
    (tset! ps 1 mc)
    void))

(bind-func divisions:[i64,ParserState*]*
  (lambda (ps)
    (pref (tref ps 2) 0)))

(bind-func divisionsPtr:[i64*,ParserState*]*
  (lambda (ps)
    (tref ps 2)))

(bind-func set_divisions:[void,ParserState*,i64]*
  (lambda (ps d)
    (pset! (tref ps 2) 0 d)
    void))
    
(bind-func beats:[i64,ParserState*]*
  (lambda (ps)
    (pref (tref ps 3) 0)))

(bind-func beatsPtr:[i64*,ParserState*]*
  (lambda (ps)
    (tref ps 3)))

(bind-func set_beats:[void,ParserState*,i64]*
  (lambda (ps b)
    (pset! (tref ps 3) 0 b)
    void))

(bind-func beatType:[i64,ParserState*]*
  (lambda (ps)
    (pref (tref ps 4) 0)))

(bind-func beatTypePtr:[i64*,ParserState*]*
  (lambda (ps)
    (tref ps 4)))

(bind-func set_beatType:[void,ParserState*,i64]*
  (lambda (ps bt)
    (pset! (tref ps 4) 0 bt)
    void))

(bind-func step:[String*,ParserState*]*
  (lambda (ps)
    (tref ps 5)))

(bind-func set_step:[void,ParserState*,String*]*
  (lambda (ps s)
    (tset! ps 5 s)
    void))

(bind-func octave:[i64,ParserState*]*
  (lambda (ps)
    (pref (tref ps 6) 0)))

(bind-func octavePtr:[i64*,ParserState*]*
  (lambda (ps)
    (tref ps 6)))

(bind-func duration:[i64,ParserState*]*
  (lambda (ps)
    (pref (tref ps 7) 0)))

(bind-func durationPtr:[i64*,ParserState*]*
  (lambda (ps)
    (tref ps 7)))

(bind-func rest:[i1,ParserState*]*
  (lambda (ps)
    (tref ps 8)))

(bind-func set_rest:[void,ParserState*,i1]*
  (lambda (ps r)
    (tset! ps 8 r)
    void))

(bind-func cParserState:[ParserState*]*
  (lambda ()
    (let ((divisionsPtr:i64* (halloc 1))
          (beatsPtr:i64* (halloc 1))
          (beatTypePtr:i64* (halloc 1))
          (octavePtr:i64* (halloc 1))
          (durationPtr:i64* (halloc 1)))
      (pset! divisionsPtr 0 0)
      (pset! beatsPtr 0 0)
      (pset! beatTypePtr 0 0)
      (pset! octavePtr 0 0)
      (pset! durationPtr 0 0)
        (let ((res (ParserState:[ParserState*,i64,i64,i64*,i64*,i64*,String*,i64*,i64*,i1]* 
                                0 
                                0
                                divisionsPtr
                                beatsPtr
                                beatTypePtr
                                (Str "")
                                octavePtr
                                durationPtr
                                #f)))
          res))))

(bind-func print:[void,ParserState*]*
  (lambda (state)
    (printf "Parser state printout:\npart count = %lld\nmeasure count = %lld\ndivisions = %lld\nbeats = %lld\nbeatType = %lld\nrest = %s\nstep = '%s'\noctave = %lld\nduration = %lld\n"
            (partCount state)
            (measureCount state)
            (divisions state)
            (beats state)
            (beatType state)
            (if (rest state) "yes" "no")
            (cstring (step state))
            (octave state)
            (duration state))
    void))




; dummy, for compilation
(bind-func xml_parse:[void,String*,Score*,ParserState*]* (lambda (a b c) void))

; central parser unit: takes an XMLelement* storage, a Score* storage and a ParserState*
; storage and reads through the data while filling the Score* object. the final product is
; a complete Score* object
(bind-func xml_interpret_element:[void,XMLelement*,Score*,ParserState*]*
  (lambda (xmlElement score state)
    (cond ((equal (name xmlElement) (Str "score-partwise"))
            (roll_error rollErr (Str "Parser: partwise score detected.") ROLL_ERR_FLAG_INFO ROLL_ERR_DEST_ALL)
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "part"))
            (roll_error rollErr (cat2 (cat2 (Str "Parser: opening part '") (attribute xmlElement (Str "id"))) (Str "'."))
                                ROLL_ERR_FLAG_INFO ROLL_ERR_DEST_ALL)
            (set_partCount state (+ 1 (partCount state)))
            (set_measureCount state 0)
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "measure"))
            (set_measureCount state (+ 1 (measureCount state)))
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "attributes"))
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "divisions"))
            (sscanf (cstring (body xmlElement)) "%lld" (divisionsPtr state)) void)
          ((equal (name xmlElement) (Str "time"))
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "beats"))
            ; DEBUG: (printf "scanning beats body: '%s'\n" (cstring (body xmlElement)))
            (sscanf (cstring (body xmlElement)) "%lld" (beatsPtr state)) void)
          ((equal (name xmlElement) (Str "beat-type"))
            ; DEBUG: (printf "scanning beat-type body: '%s'\n" (cstring (body xmlElement)))
            (sscanf (cstring (body xmlElement)) "%lld" (beatTypePtr state)) void)
          ((equal (name xmlElement) (Str "note"))
            ; DEBUG: (printf "scanning note body: '%s'\n" (cstring (body xmlElement)))
            (set_rest state #f)
            (xml_parse (body xmlElement) score state)
            ; write note to score
            ; update time
            void)
          ((equal (name xmlElement) (Str "pitch"))
            (xml_parse (body xmlElement) score state))
          ((equal (name xmlElement) (Str "rest"))
            (set_rest state #t))
          ((equal (name xmlElement) (Str "step"))
            ; DEBUG: (printf "scanning step body: '%s'\n" (cstring (body xmlElement)))
            (set_step state (body xmlElement)) void)
          ((equal (name xmlElement) (Str "octave"))
            ; DEBUG: (printf "scanning octave body: '%s'\n" (cstring (body xmlElement)))
            (sscanf (cstring (body xmlElement)) "%lld" (octavePtr state)) void)
          ((equal (name xmlElement) (Str "duration"))
            ; DEBUG: (printf "scanning duration body: '%s'\n" (cstring (body xmlElement)))
            (sscanf (cstring (body xmlElement)) "%lld" (durationPtr state)) void)
          (else (roll_error rollErr
                            (cat2 (cat2 (Str "Roll, xml_interpret_element: ignoring element '") (name xmlElement)) (Str "' and its content and sub-elements."))
                            ROLL_ERR_FLAG_INFO
                            ROLL_ERR_DEST_ALL))
                void)))






(bind-func xml_parse:[void,String*,Score*,ParserState*]*
  (lambda (xmlData score state)
    (cond ((null? xmlData) (roll_error rollErr
                                       (Str "Roll, xml_parse: undefined xmlData pointer.  No parsing possible.")
                                       ROLL_ERR_FLAG_FATAL
                                       ROLL_ERR_DEST_ALL)
                           void)
          ((= 0 (length xmlData)) void)
          (else
            (let ((first (substring xmlData 0 2)))
              (cond ((equal first (Str "<?"))
                      ;DEBUG: (printf "xmlData:\n%s\n" (cstring (xml_skip_version_element xmlData)))
                      (xml_parse (xml_skip_version_element xmlData) score state))
                    ((equal first (Str "<!"))
                      ;DEBUG: ;(printf "xmlData:\n%s\n" (cstring (xml_skip_doctype_element xmlData)))
                      (xml_parse (xml_skip_doctype_element xmlData) score state))
                    (else 
                      (let ((pair (xml_divide xmlData))
                            (xmlElement (cXMLelement)))
                        ;DEBUG: (print pair)
                        (xml_read_element (xml_car pair) xmlElement)
                        (xml_interpret_element xmlElement score state)
                        (xml_parse (xml_cdr pair) score state)))))))))
        

(bind-func xml_import:[void,Score*,String*]*
  (lambda (score filepath)
    (let ((xmlFile (Str (sys_slurp_file (cstring filepath)))))
      (cond
        ((null? xmlFile) (roll_error rollErr
                                     (Str "Roll, xml_import: xml file could not be opened. Aborting.")
                                     ROLL_ERR_FLAG_FATAL
                                     ROLL_ERR_DEST_ALL)
                         void)
        ((= 0 (length xmlFile)) (roll_error rollErr
                                            (Str "Roll, xml_import: xml data empty. No parsing.")
                                            ROLL_ERR_FLAG_FATAL
                                            ROLL_ERR_DEST_ALL))
        (else
          (let ((state (cParserState)))
            (roll_error rollErr
                        (Str "XML file slurped.")
                        ROLL_ERR_FLAG_INFO
                        ROLL_ERR_DEST_ALL)
            ;DEBUG: (printf "file contents:\n%s\n" (cstring xmlFile))
            (xml_parse xmlFile score state)
            ;DEBUG: (printf "this went well.\n")
            ;DEBUG: 
            (print state)
            void)))
    void)))
